# Compile and run simple program on CPU {#cpu_dev}

## Namespace and header files
The monolish namespace contains monolish::vector and monolish::view1D.
monolish has the following 7 namespaces in addition to the monolish namespace:
- monolish::matrix : Provides classes for Dense and Sparse matrices. This can be used by including other header files.
- monolish::blas : Provides a monolithic BLAS API that eliminates dependencies on data types, matrix format, and hardware-specific APIs. This is included in `monolish_blas.hpp`.
- monolish::vml : Provides the calculation of mathematical functions to each element of a vector. This is an open source implementation of the [VML functions included in Intel MKL](https://software.intel.com/content/www/us/en/develop/articles/new-mkl-vml-api.html). This is included in `monolish_vml.hpp`.
- monolish::equation : Provides a solution for linear equations.	This is included in `monolish_equation.hpp`.
- monolish::standard_eigen : Provides solutions to standard eigenvalue problems. This is included in `monolish_eigen.hpp`.
- monolish::generalized_eigen : Provides a solution to the generalized eigenvalue problem. This is included in `monolish_generalized_eigen.hpp`.
- monolish::util : Provides utility functions. This can be used by including other header files.


## Compute innerproduct 
First, a simple inner product program is shown below:

\code{.cpp}
#include<iostream>
#include<monolish_blas.hpp>
void main(){
  size_t N = 100;
  monolish::vector<double> x(N, 1.0); // x = {1,1,...,1}, length N
  monolish::vector<double> y(N, 1.0, 2.0); // Random vector length N with values in the range 1.0 to 2.0

  double ans = monolish::blas::dot(x, y); // compute innerproduct

  std::cout << ans << std::endl;
}
\endcode

- A monolish::vector can be declared like a std::vector.
- As an extension, monolish::vector can also create random vectors.
- The inner product function is monolish::blas::dot(). It does not need type-dependent function names like sdot or ddot.
- For the BLAS library called inside monolish::vector::dot(), see [here](@ref oplist).
- At the end of the function, the memory of monolish::vector is automatically released by the destructor.

This program will be executed in parallel. 
The number of threads is specified by the `OMP_NUM_THREADS` environment variable.

## Solve Ax=b
The following is a sample program that solves a linear equations; Ax=b using the conjugate gradient method with jacobi preconditioner.

\code{.cpp}
#include<iostream>
#include<monolish_equation.hpp>

void main(){
  monolish::matrix::COO<double> A_COO("test_matrix.mtx") // Input from file
  // Edit the matrix as needed //
  // Execute A_COO.sort() after editing the matrix //
  monolish::matrix::CRS<double> A(A_COO) // Create CRS format and convert from COO format

  monolish::vector<double> x(A.get_row(), 1.0, 2.0); length A.row
  monolish::vector<double> b(A.get_row(), 1.0, 2.0); // Random vector length N with values in the range 1.0 to 2.0

  monolish::equation::CG<monolish::matrix::CRS, double> solver; // Create CG class

  monolish::equation::Jacobi precond; // create jacobi preconditioner
  solver.set_create_precond(precond); // set preconditioner creation to CG solver
  solver.set_apply_precond(precond); // set preconditioner application function to CG solver

  solver.set_tol(1.0e-12);
  solver.set_maxiter(A.get_row()); 

  monolish::util::solver_check(solver.solve(A, x, b)); //solver Ax=b by CG with jacobi

  x.print_all();
}
\endcode


### Matrix creation

monolish::matrix::COO has `editable` attribute, so users can edit any element using @ref monolish::matrix::COO.insert() "insert()" and monolish::matrix::COO.at() "at()" functions. COO can be created by giving array pointer or file name to the constructor.
This sample program creates a matrix from a file.
The input file is in [MatrixMarket format](https://math.nist.gov/MatrixMarket/formats.html).
MatrixMarket format is a common data format. It can also be output by [scipy](https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.mmwrite.html#scipy.io.mmwrite).

monolish::matrix::CRS can be easily generated by taking COO as an argument to the constructor. 

### Solving Ax=b
monolish proposes a new way to implement linear solvers.

Applying preprocessing means combining multiple solvers. In other words, the solver and preconditioner in the Krylov subspace method are essentially the same thing.

The solver class included in monolish::equation has the following functions:
- @ref monolish::equation::CG.solve() "solve()" : Solve the simultaneous linear equations.
- @ref monolish::equation::CG.create_precond() "create_precond()" : Create the preconditioning matrix M.
- @ref monolish::equation::CG.apply_precond() "apply_precond()" : Apply preconditioner according to the created preprocessing matrix M.
- @ref monolish::equation::CG.set_create_precond() "set_create_precond()" : Register another class' create_precond to the class as a function to create the preprocessing matrix.
- @ref monolish::equation::CG.set_apply_precond() "set_apply_precond()" : Register "apply_precond" of another class to the class as a function to apply preprocessing.

The class that executes `solve()` will execute the registered `create_precond()` and `apply_precond()`.
If no preconditioner is registered, it calls monolish::equation::none as "none preconditioner".

By being able to register the creation and application of preconditioners separately, users can use the preconditioner matrix in different ways.

In the current version, the create_precond() and apply_precond() functions of some classes do not work.
In the future, we will make these functions work in all classes.
This implementation would be very efficient for multi-grid methods.

## Improve solver program
The program in the previous chapter has the matrix storage format, data type, solver name, and preconditioner name written all over the program.

If users want to change them depending on the input matrix, this implementation requires a lot of program changes.

Since monolish is designed so that the matrix and solver classes all have the same interface, these changes can be eliminated by templating.

A templated program is shown below.

\code{.cpp}
#include<iostream>
#include<monolish_equation.hpp>

template<typename MATRIX, typename SOLVER, typename PRECOND, typename FLOAT>
void solve(){
  monolish::matrix::COO<FLOAT> A_COO("test_matrix.mtx") // Input from file
  // Edit the matrix as needed //
  // Execute A_COO.sort() after editing the matrix //
  MATRIX A(A_COO) // Create CRS format and convert from COO format

  monolish::vector<FLOAT> x(A.get_row(), 1.0, 2.0); length A.row
  monolish::vector<FLOAT> b(A.get_row(), 1.0, 2.0); // Random vector length N with values in the range 1.0 to 2.0

  SOLVER solver; // Create solver

  PRECOND precond;
  solver.set_create_precond(precond);
  solver.set_apply_precond(precond);

  solver.set_tol(1.0e-12);
  solver.set_maxiter(A.get_row());

  monolish::util::solver_check(solver.solve(A, x, b));

  x.print_all(); // output x to standard output
}

void main(){
  // A is Dense, solver is CG, precondition is Jacobi, precision is double
  solve<
    monolish::matrix::CRS<double>, 
    monolish::equation::CG<monolish::matrix::CRS<double>,double>,
    monolish::equation::Jacobi<monolish::matrix::CRS<double>,double>,
    double>();

  // A is Dense, solver is BiCGSTAB, precondition is none, precision is float
  solve<
    monolish::matrix::Dense<float>, 
    monolish::equation::BiCGSTAB<monolish::matrix::CRS<float>,float>,
    monolish::equation::none<monolish::matrix::CRS<float>,float>,
    float>();
}
\endcode

This program can be templated so that the function that solves for Ax=b is not oblivious to the matrix storage format or data type.
